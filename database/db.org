#+TITLE: DB
#+AUTHOR: renpeng


** B树 B-树 B+树 B*树
   1. B树既是二叉搜索树，有如下特性。在接近平衡二叉树时，效率最高（相当于二分查找），但是在进过多次增删后，可能会出现所有元素朝向一边（线性）的情况。所以如何保证B树结构分布均匀的平衡算法是平衡二叉树的关键。平衡算法是B树中插入和删除节点时的策略
      + 所有非叶子节点至多拥有两个儿子（left和right）
      + 非叶子节点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树
      + 所有节点存储一个关键字

   2. B-树是多路搜索树
      + 同时限定了层级和分叉个数
      + 关键字也是分布在整棵树中
      + 非根非叶子节点里的关键字表明了子树的数值范围，同时也表明了子树的个数。如关键字为8、12，那么会有3棵子树分别小于8、大于8小于12、大于12
      + 搜索可以在非叶子节点中结束
      + 元素有M/2的限定，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；


   1. B+树跟B-树类似，也是多路搜索树
      + 非根非叶子节点不存储关键字，所有关键字均在叶子节点，非根非叶子节点即作为叶子节点的索引（适合存储和文件系统）
      + 非根非叶子节点也是存储子树的数值范围，但是范围略有不同，如关键字8和12，那么会有2棵子树，分别是大于8小于12、大约12
      + 叶子节点持有数据链表指针，用于搜索数据

   2. B* 树
      + 为非根非叶子节点也增加一个链表指针
      + 将节点的利用率从1/2提高到2/3

** db存储结构
聚集索引：数据行的物理顺序与列值（一般是主键）的逻辑顺序相同，一个表中只能有一个聚集索引。可以认为聚集索引是索引组织表特有的。
非聚集索引：聚集索引以外的其他索引，分为普通索引、唯一索引、全文索引。

堆表
1. 堆就是无序数据的集合，索引就是将数据变得有序，在索引中键值有序，数据还是无序的；
2. 数据存放在数据里，索引存放在索引里；
3. 堆表中，主键索引和普通索引一样，和非空唯一索引没有区别。索引叶子节点存放的是指向堆表数据的指针（可以是页码和偏移量），指向物理地址，没有回表的说法；
4. mysql的myISAM，Oracle，pg都支持的是堆表

索引组织表
1. 索引组织表是一个B树存储结构，是按主键有序的，可变的。
2. 对于主键索引，叶子节点存放了所有行数据（即聚集索引），其他索引称为辅助索引，只存储索引键和主键；
3. innodb就是索引组织表
4. inndb数据存放在聚集索引中


** mysql
mysql提供多种存储引擎，用户还可以按照协议自定义存储引擎。innodb原本也是第三方引擎，擅长处理oltp业务，MyISAM引擎不支持事务，仅支持表级锁，擅长处理olap业务

*** mysql体系结构

1. mysql对外提供的交互接口（Connector）
2. 管理服务组件和工具组件（Management service & Utilities）
3. 连接池组件（Connection pool）
4. sql接口组件（sql interface）
5. 查询分析器组件（parser）
6. 优化器组件（optimizer）
7. 缓存组件（cache & buffer）
8. 插件式存储引擎（Pluggable storage engine）
9. 物理文件（file system）


*** innodb体系架构
1. 内存
   + 缓冲池，包括数据页、索引页、undo页、insert buffer，自适应哈希索引 adaptive hash index，innodb锁信息lock info，数据字典data dictionary
   + LRU list，free list和flush list。



2. 后台线程
   + master thread
   + io thread
   + purge thread
   + page cleaner thread



**** insert buffer 解决非聚集索引构建时的离散读盘问题
**** double write 二次写，提高数据页可靠性
**** 自适应哈希索引
**** 异步iO
**** 启动关闭与恢复机制


*** mysql文件
1. 参数文件 my.cnf
2. 日志文件
   + 错误日志 error log
   + 二进制日志 binlog
   + 慢查询日志 slow query log
   + 查询日志 log
3. socket文件
4. pid文件
5. mysql表结构文件
6. 存储引擎文件
   + 表空间文件ibdata
   + 重做日志ib_logfile0,ib_logfile1


** mysql表
1. 在innodb存储引擎中，表都是根据主键顺序存放的，这种存储方式的表称作索引组织表 index organized table
2. innodb所有数据都被逻辑地存放在一个空间中，称之为表空间tablespace。表空间又由段（segment），区（extent），页（page或block）组成
** mysql 数据复制策略
*** mysql复制架构衍生史
在2000年，MySQL 3.23.15版本引入了Replication。Replication作为一种准实时同步方式，得到广泛应用。这个时候的Replicaton的实现涉及到两个线程，一个在Master，一个在Slave。Slave的I/O和SQL功能是作为一个线程，从Master获取到event后直接apply，没有relay log。这种方式使得读取event的速度会被Slave replay速度拖慢，当主备存在较大延迟时候，会导致大量binary log没有备份到Slave端。

在2002年，MySQL 4.0.2版本将Slave端event读取和执行独立成两个线程（IO线程和SQL线程），同时引入了relay log。IO线程读取event后写入relay log，SQL线程从relay log中读取event然后执行。这样即使SQL线程执行慢，Master的binary log也会尽可能的同步到Slave。当Master宕机，切换到Slave，不会出现大量数据丢失

在2010年MySQL 5.5版本之前，一直采用的是这种异步复制的方式。主库的事务执行不会管备库的同步进度，如果备库落后，主库不幸crash，那么就会导致数据丢失。于是在MySQL在5.5中就顺其自然地引入了半同步复制，主库在应答客户端提交的事务前需要保证至少一个从库接收并写到relay log中。那么半同步复制是否可以做到不丢失数据呢？下面分析。

在2016年，MySQL在5.7.17中引入了一个全新的技术，称之为InnoDB Group Replication。目前官方MySQL 5.7.17基于Group replication的全同步技术已经问世，全同步技术带来了更多的数据一致性保障。相信是未来同步技术一个重要方向，值得期待。MySQL 5.7 Group Replication


*** 3种复制方式
1. 对于异步复制，主库将事务Binlog事件写入到Binlog文件中，此时主库只会通知一下Dump线程发送这些新的Binlog，然后主库就会继续处理提交操作，而此时不会保证这些Binlog传到任何一个从库节点上。
2. 对于全同步复制，当主库提交事务之后，所有的从库节点必须收到，APPLY并且提交这些事务，然后主库线程才能继续做后续操作。这里面有一个很明显的缺点就是，主库完成一个事务的时间被拉长，性能降低。
3. 对于半同步复制，是介于全同步复制和异步复制之间的一种，主库只需要等待至少一个从库节点收到并且Flush Binlog到Relay Log文件即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全执行并且提交的反馈，这样就节省了很多时间。

** 数据中心容灾策略
*** 同城容灾
** 主备数据同步
MySQL 主备之间使用逻辑日志 binlog 进行数据同步，主库事务完成后将产生的 binlog 发送给备库，备库 IO thread 将收到的 binlog 写入到磁盘，然后由 SQL thread 执行或由分发线程分发到 worker thread 后执行，从而保证主备之间的数据一致，但是基于 binlog 的逻辑复制存在着以下问题：
1. 主备数据延迟， 即 binlog 执行性能所引起的主备延迟问题。binlog 在执行过程中需要完整的 B+ 树遍历过程，并在执行的过程中产生 redo log & binlog，当主库压力大到一定程度时，备库执行性能由于并发的原因会跟不上主库的执行速度，最终产生延迟问题；
2. 数据不一致问题， binlog 内部 bug 会导致主备之间的数据不一致性，如 replace into 导致的主备 auto_increment 不一致性，repository 所导致的主备数据不一致问题, insert ... select 所导致的主备不一致问题等；
3. 大事务问题，binlog 在事务完成后才被发送到备库，备库则执行和主库相同的逻辑，执行需要的时间和主库基本相同或更多（row 模式无主建更新等），所以没有办法解决大事务所带来的延迟问题

** mvcc机制
Multiversion concurrency control，多版本并发控制，提供并发访问数据库时，对事务内读取的到的内存做处理，用来避免写操作堵塞读操作的并发问题。


** redo log与undo log
innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。

undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：
1. redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)
2. undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。

redo log不是二进制日志。虽然二进制日志中也记录了innodb表的很多操作，也能实现重做的功能，但是它们之间有很大区别。
1. 二进制日志是在存储引擎的上层产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改。并且二进制日志先于redo log被记录
2. 二进制日志记录操作的方法是逻辑性的语句。即便它是基于行格式的记录方式，其本质也还是逻辑的SQL设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中每个页的修改。
3. 二进制日志只在每次事务提交的时候一次性写入缓存中的日志"文件"(对于非事务表的操作，则是每次执行语句成功后就直接写入)。而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作。
4. 因为二进制日志只在提交的时候一次性写入，所以二进制日志中的记录方式和提交顺序有关，且一次提交对应一次记录。而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录
5. 事务日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练。幂等性的意思是多次操作前后状态是一样的，例如新插入一行后又删除该行，前后状态没有变化。而二进制日志记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次。

** 分布式数据库：cynosDB与Aurora
1. 计算和存储分离
2. 基于redo log传递，减少io
