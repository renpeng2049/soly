#+TITLE: DB
#+AUTHOR: renpeng


** B树 B-树 B+树 B*树
   1. B树既是二叉搜索树，有如下特性。在接近平衡二叉树时，效率最高（相当于二分查找），但是在进过多次增删后，可能会出现所有元素朝向一边（线性）的情况。所以如何保证B树结构分布均匀的平衡算法是平衡二叉树的关键。平衡算法是B树中插入和删除节点时的策略
      + 所有非叶子节点至多拥有两个儿子（left和right）
      + 非叶子节点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树
      + 所有节点存储一个关键字

   2. B-树是多路搜索树
      + 同时限定了层级和分叉个数
      + 关键字也是分布在整棵树中
      + 非根非叶子节点里的关键字表明了子树的数值范围，同时也表明了子树的个数。如关键字为8、12，那么会有3棵子树分别小于8、大于8小于12、大于12
      + 搜索可以在非叶子节点中结束
      + 元素有M/2的限定，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；


   1. B+树跟B-树类似，也是多路搜索树
      + 非根非叶子节点不存储关键字，所有关键字均在叶子节点，非根非叶子节点即作为叶子节点的索引（适合存储和文件系统）
      + 非根非叶子节点也是存储子树的数值范围，但是范围略有不同，如关键字8和12，那么会有2棵子树，分别是大于8小于12、大约12
      + 叶子节点持有数据链表指针，用于搜索数据

   2. B* 树
      + 为非根非叶子节点也增加一个链表指针
      + 将节点的利用率从1/2提高到2/3

** db存储结构
聚集索引：数据行的物理顺序与列值（一般是主键）的逻辑顺序相同，一个表中只能有一个聚集索引。可以认为聚集索引是索引组织表特有的。
非聚集索引：聚集索引以外的其他索引，分为普通索引、唯一索引、全文索引。

堆表
1. 堆就是无序数据的集合，索引就是将数据变得有序，在索引中键值有序，数据还是无序的；
2. 数据存放在数据里，索引存放在索引里；
3. 堆表中，主键索引和普通索引一样，和非空唯一索引没有区别。索引叶子节点存放的是指向堆表数据的指针（可以是页码和偏移量），指向物理地址，没有回表的说法；
4. mysql的myISAM，Oracle，pg都支持的是堆表

索引组织表
1. 索引组织表是一个B树存储结构，是按主键有序的，可变的。
2. 对于主键索引，叶子节点存放了所有行数据（即聚集索引），其他索引称为辅助索引，只存储索引键和主键；
3. innodb就是索引组织表
4. inndb数据存放在聚集索引中


** mysql
mysql提供多种存储引擎，用户还可以按照协议自定义存储引擎。innodb原本也是第三方引擎，擅长处理oltp业务，MyISAM引擎不支持事务，仅支持表级锁，擅长处理olap业务

*** innodb体系架构
1. 内存
   + 缓冲池，包括数据页、索引页、undo页、insert buffer，自适应哈希索引 adaptive hash index，innodb锁信息lock info，数据字典data dictionary
   + LRU list，free list和flush list。



2. 后台线程
   + master thread
   + io thread
   + purge thread
   + page cleaner thread



**** insert buffer 解决非聚集索引构建时的离散读盘问题
**** double write 二次写，提高数据页可靠性
**** 自适应哈希索引
**** 异步iO
**** 启动关闭与恢复机制


*** mysql文件
1. 参数文件 my.cnf
2. 日志文件
   + 错误日志 error log
   + 二进制日志 binlog
   + 慢查询日志 slow query log
   + 查询日志 log
3. socket文件
4. pid文件
5. mysql表结构文件
6. 存储引擎文件
   + 表空间文件ibdata
   + 重做日志ib_logfile0,ib_logfile1


** mysql表
1. 在innodb存储引擎中，表都是根据主键顺序存放的，这种存储方式的表称作索引组织表 index organized table
2. innodb所有数据都被逻辑地存放在一个空间中，称之为表空间tablespace。表空间又由段（segment），区（extent），页（page或block）组成
** mysql 数据复制策略
*** mysql复制架构衍生史
在2000年，MySQL 3.23.15版本引入了Replication。Replication作为一种准实时同步方式，得到广泛应用。这个时候的Replicaton的实现涉及到两个线程，一个在Master，一个在Slave。Slave的I/O和SQL功能是作为一个线程，从Master获取到event后直接apply，没有relay log。这种方式使得读取event的速度会被Slave replay速度拖慢，当主备存在较大延迟时候，会导致大量binary log没有备份到Slave端。

在2002年，MySQL 4.0.2版本将Slave端event读取和执行独立成两个线程（IO线程和SQL线程），同时引入了relay log。IO线程读取event后写入relay log，SQL线程从relay log中读取event然后执行。这样即使SQL线程执行慢，Master的binary log也会尽可能的同步到Slave。当Master宕机，切换到Slave，不会出现大量数据丢失

在2010年MySQL 5.5版本之前，一直采用的是这种异步复制的方式。主库的事务执行不会管备库的同步进度，如果备库落后，主库不幸crash，那么就会导致数据丢失。于是在MySQL在5.5中就顺其自然地引入了半同步复制，主库在应答客户端提交的事务前需要保证至少一个从库接收并写到relay log中。那么半同步复制是否可以做到不丢失数据呢？下面分析。

在2016年，MySQL在5.7.17中引入了一个全新的技术，称之为InnoDB Group Replication。目前官方MySQL 5.7.17基于Group replication的全同步技术已经问世，全同步技术带来了更多的数据一致性保障。相信是未来同步技术一个重要方向，值得期待。MySQL 5.7 Group Replication


*** 3种复制方式
1. 对于异步复制，主库将事务Binlog事件写入到Binlog文件中，此时主库只会通知一下Dump线程发送这些新的Binlog，然后主库就会继续处理提交操作，而此时不会保证这些Binlog传到任何一个从库节点上。
2. 对于全同步复制，当主库提交事务之后，所有的从库节点必须收到，APPLY并且提交这些事务，然后主库线程才能继续做后续操作。这里面有一个很明显的缺点就是，主库完成一个事务的时间被拉长，性能降低。
3. 对于半同步复制，是介于全同步复制和异步复制之间的一种，主库只需要等待至少一个从库节点收到并且Flush Binlog到Relay Log文件即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全执行并且提交的反馈，这样就节省了很多时间。

** 数据中心容灾策略
*** 同城容灾
